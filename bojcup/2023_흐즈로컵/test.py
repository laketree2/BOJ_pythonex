'''
입력받은 개수만큼 좌표를 만들어 정렬(절댓값이 0, 0에서 제일 가까운 것 순서대로?)
수열 안에 들어오는 사람부터 달팽이 수열 스타트
처음부터 좌표를 시계방향으로 정렬한다면?
근데 이차원 배열 요소는 배열이라 좌표 이동 사용이 불가함,,
'''

'''
좌표를 시계방향으로 정렬한 후 , 각각의 좌표를 받아 이차원 배열에 저장함.
각 좌표를 절댓값 기준으로 재정렬
while true 반복문을 돌면서 첫번째 좌표에 있는 용사부터 0,0으로 이동시킴
[동시에 겹치는 부분을 어떻게 처리? -> 한명씩 dfs하거나, 여러명을 bfs 하듯이?]
이동값에 해당되는 알파벳을 리스트에 저장
visited 배열을 만들어서 이동이 끝날 때마다 좌표값을 넣어줌(재방문 금지용)[만일 한 명 dfs 돌리듯이 처리할 것이라면, 이 부분에 대한 처리가 필요함]
0,0에 도달하면 해당 리스트에서 뺌
최종 길이가 0에 도달하면 break를 걸어 탈출한 후 리스트 안의 값을 차례로 출력
'''
import sys
input = sys.stdin.readline

n = int(input()) #입력값
n_list = [] #좌표값
plans = [] #이동값 출력할 리스트

# key = ['A', 'Q', 'W', 'E', 'D', 'C', 'X', 'Z']
# key_dict = dict(zip(key, list(range(len(key)))))
#move = {'A':[-1, 0], 'Q':[-1, 1], 'W':[0, 1], 'E':[1, 1], 'D':[1, 0], 'C':[1, -1], 'X':[0, -1], 'Z':[-1, -1]}
# dx = [-1,-1, 0, 1, 1, 1, 0, -1]
# dy = [0, 1, 1, 1, 0, -1, -1, -1]

#시계방향 정렬
dx = [0, 1, 1, 1, 0, -1, -1, -1]
dy = [1, 1, 0, -1, -1, -1, 0, 1]
mapper = {'W':0, 'E':1, 'D':2, 'C':3, 'X':4, 'Z':5, 'A':6, 'Q':7}

#각각의 좌표 받기
for k in range(n):
    x, y = map(int, input().split())
    n_list.append([x, y])
    #n_list.append((i, j))

while(True): #모든 요소가 0, 0에 도달할 때까지
    #각각의 좌표에 대해 입력값을 한번에 바꾸고 싶은데
    for i in range(8): #8방향에 대해서
        nx = x + dx[i][0]
        ny = y + dy[i][1]
        #좌표 안 겹치면(리스트의 값이 같지 않으면)
        plans.append() #움직인 좌표값에 해당되는 값을 넣어줌
    x, y = nx, ny
    #0,0에 도달하면 리스트에서 제외
    if n_list[[x, y]] == 0:
        n_list.pop()
    if not n_list: #리스트에 아무것도 없으면 
        break
    #시계방향 정렬
for m in plans:
    print(*m, sep = '')